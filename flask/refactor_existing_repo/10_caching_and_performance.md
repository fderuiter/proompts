# 10. Caching and Performance

**Goal:** Implement a sensible caching strategy and establish a performance baseline to improve response times and reduce database load.

**Context:**
*   This task is for applications that are experiencing performance issues, such as slow endpoints or excessive database queries.
*   The primary caching backend will be Redis.

**Tasks:**

1.  **Integrate Flask-Caching:**
    *   Add `Flask-Caching` to the dependencies.
    *   Configure the extension to use a Redis backend. The Redis URL should be loaded from the environment.
    *   Establish a clear key prefixing strategy to avoid key collisions if the Redis instance is shared.
    *   Define default TTL (Time To Live) values for caches.

2.  **Implement Caching Strategies:**
    *   **Memoization:** Use the `@cache.memoize()` decorator to cache the results of expensive, pure functions (functions that return the same output for the same input).
    *   **View Caching:** Use the `@cache.cached()` decorator to cache the entire response of endpoints that serve data that does not change frequently.
    *   **Cache Invalidation:** Implement a strategy for invalidating the cache when the underlying data changes. This can be done explicitly (`cache.delete()`) or by using more advanced techniques like event-driven cache invalidation.

3.  **Profile and Optimize Hot Endpoints:**
    *   Use a profiler (e.g., `werkzeug.middleware.profiler` or a more advanced tool like `py-spy`) to identify "hot spots" in the code â€“ the endpoints or functions that are consuming the most time.
    *   Specifically look for and eliminate N+1 query problems, where a loop issues a separate database query for each item. Use SQLAlchemy's `joinedload` or `selectinload` options to eager-load related objects.

4.  **Implement HTTP Caching and Compression:**
    *   **Gzip Compression:** Configure the WSGI server (`gunicorn`, `uwsgi`) or a reverse proxy (`nginx`) to compress responses with `gzip`.
    *   **Conditional Responses:** Use ETags to implement conditional GET requests. This allows clients to avoid re-downloading data that has not changed. Flask-Caching can help manage ETags automatically.

**Deliverables:**
*   A diff showing the new `Flask-Caching` dependency and the application of caching decorators to relevant functions and views.
*   A performance report (`performance.md`) that documents:
    *   The baseline latency and query counts for the profiled hot endpoints.
    *   The improved latency and query counts after optimization.
*   An updated `docker-compose.yml` that includes a Redis service for caching.

**Acceptance Criteria:**
*   The application uses Redis for caching, configured via environment variables.
*   At least one slow endpoint has been identified, optimized, and its performance improvement documented.
*   N+1 query issues have been identified and fixed.
*   The latency and database query count improvements are clearly documented.

**Agent Tips:**
*   Be careful what you cache. Do not cache responses that contain user-specific data unless the cache key is also user-specific.
*   Caching can make debugging more difficult. Make it easy to disable the cache in your local development environment.
*   When optimizing database queries, use a tool like `Flask-SQLAlchemy`'s query logger or a dedicated APM to see the exact SQL queries being generated by your code.
*   Start with a simple caching strategy and add more complexity only as needed. Over-caching can lead to its own set of problems.
